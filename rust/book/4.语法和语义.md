### 4.2 函数

#### 表达式 VS 语句

Rust主要是一个基于表达式的语言, 只有两种语句, 其他一切都是表达式

```rust
fn add_one(x: i32) -> i32 {
  x + 1
}

// 此处如果加上semicolon, 则不会正常返回, 会被认为是一个语句, 而表达式则会返回一个值, 这才是推荐的写法
```

#### diverging function 发散函数

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
// 类型throw一个error
```

#### 函数指针

```rust
fn plus_one(i: i32) -> i32 {
  i + 1
}

let f: fn(i32) -> i32 = plus_one

let result = f(5)
```

### 4.3 primitive types 原生类型

1. 布尔型
2. char
3. 数字类型 `i8`, `i16`, `u16`, `f64`, `isize`
4. 数组

```rust
let a = [0; 20] // a: [i32; 20], 初始化了含有20个0的数组
```

> 切片 slices

```rust
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // A slice containing all of the elements in `a`.
let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.
```

5. str 最原始的字符串类型, 为不定长类型
6. 元组 tuples

> 元组的索引

```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

7. 函数

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i: 32) -> i32 = foo;
```

### If语句

因为if是一个表达式, 所以可以这么写

```rust
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
```

### loop循环

提供了三种方法来进行一些迭代才做, 分别为`loop`, `while`以及`for`

1. loop

这个为无限循环, 使用`break`来终止循环

2. while

```rust
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!("{}", x);

    if x % 5 == 0 {
        done = true;
    }
}
```

3. for

```rust
for x in 0..10 {
    println!("{}", x); // x: i32
}

// 更抽象的形式 这个表达式是一个迭代器
for var in expression {
    code
}
```

4. Enumerate方法

当你想知道已经循环了多少次的时候, 需要使用`.enumerate()函数`

```rust
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}
```

5. 循环标签 Loop labels

```rust
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}
```

### 4.7 Vectors

实现的标准库为Vec<T>, 也可以使用vec!宏来创建它

```rust
let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>
let v = vec![0; 10]; // ten zeroes
```

#### 访问元素

值得注意的是, 必须使用`usize`类型的值进行索引

```rust
let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// Works:
v[i];

// Doesn’t:
v[j];
```

为了不出现out of bounds error, 我们可以使用`get`或者`get_mut`来获取元素, 若索引无效的话, 会返回None

```rust
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}
```

#### iterate

```rust
let mut v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("A reference to {}", i);
}

for i in &mut v {
    println!("A mutable reference to {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}

// 需要注意的是 最后一个方法将不能再次使用同样的方法遍历vector, 其余两种使用引用的方法就不会出现这样的问题
```

### 4.8 所有权

rust注重安全和速度, 通过很多zero-cost abstractions 零开销抽象来实现这些目标, 分析都在编译时完成, 不需要再运行时为这些功能付出任何开销

#### 所有权 ownership

Rust 中的[变量绑定](Variable Bindings)有一个属性：它们有它们所绑定的的值的所有权。这意味着当一个绑定离开作用域，它们绑定的资源就会被释放。例如：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

当进入作用域时, 一个vector在栈上被创建, 并在堆上为它的3个元素分配了空间, 离开作用域以后, rust将会清理掉与vector相关的一切, 甚至是堆上的分配的内存


#### 移动语义 move semantics

然而这里有更巧妙的地方：Rust 确保了对于任何给定的资源都正好（只）有一个绑定与之对应。例如，如果我们有一个 vector，我们可以把它赋予另外一个绑定：

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]); // error
```

下面的例子会出现一样的错误, 我们把所有权转移给了别的绑定时, 我们说我们移动了我们引用的值

```rust
fn take(v: Vec<i32>) {
    // What happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

#### Copy类型

我们已经知道了当所有权被转移给另一个绑定以后，你不能再使用原始绑定。然而，有一个trait会改变这个行为，它叫做Copy。我们还没有讨论到 trait，不过目前，你可以理解为一个为特定类型增加额外行为的标记。例如：

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);

// i32并没有指向其他数据的指针, 对他的拷贝是一个完整的拷贝
```

所有基本类型都实现了`copy trait`, 不遵循所有权规则


### 4.9 引用与借用

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

// can not use v1 v2 again
```

然后上面的并不是rust理想的代码

```rust
fn main() {
    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed.
    fn sum_vec(v: &Vec<i32>) -> i32 {
        return v.iter().fold(0, |a, &b| a + b);
    }
    // Borrow two vectors and sum them.
    // This kind of borrowing does not allow mutation through the borrowed reference.
    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
        // Do stuff with `v1` and `v2`.
        let s1 = sum_vec(v1);
        let s2 = sum_vec(v2);
        // Return the answer.
        s1 + s2
    }

    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5, 6];

    let answer = foo(&v1, &v2);
    println!("{}", answer);
}
```

引用是不可能变的, 意味着在foo当中, 向量完全不能被改变

```rust
fn foo(v: &Vec<i32>) {
     v.push(5); // cannot borrow immutable borrowed content `*v` as mutable
}

let v = vec![];

foo(&v);
```

#### &mut 引用

这是第二种类型的引用: &mut T, 一个可变引用允许你改变你借用的资源

```rust
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

#### 规则

1. 任何借用必须位于比拥有者更小的作用域
2. 对于同一个资源的借用, 以下的情况不能同时出现在同一个作用域下: 简单的说就是同一个作用域下不能同时存在不可变和可变的引用
- 1个或者多个不可变引用(&T)
- 唯一1个可变引用(&mut T)

```rust
fn main() {
    let mut x = 5;

    let y = &mut x;    // -+ &mut borrow of `x` starts here.
                       //  |
    *y += 1;           //  |
                       //  |
    println!("{}", x); // -+ - Try to borrow `x` here.
}                      // -+ &mut borrow of `x` ends here.
```

解决方法为上面的代码, 添加大括号即可

#### 释放后使用

引用必须与它引用的值存活的一样长

```rust
let y: &i32;
let x = 5;
y = &x;

println!("{}", y);

// error: x does not live long enough
```

在上面的例子中, y在x之前被申明, 所以y的生命周期更长, 这是不被允许的

### 4.10 生命周期 Lifetimes

思考下面的例子:

```rust
fn skip_prefix(line: &str, prefix: &str) -> &str {
    // ...
#   line
}

let line = "lang:en=Hello World!";
let lang = "en";

let v;
{
    let p = format!("lang:{}=", lang);  // -+ `p` comes into scope.
    v = skip_prefix(line, p.as_str());  //  |
}                                       // -+ `p` goes out of scope.
println!("{}", v);
```

我们需要保证借用的引用在使用的时候没有被释放, 所以上面的例子rust是不会编译成功的话, 为了成功我们需要引入引用生命周期信息

```rust
fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {
    // ...
#   line
}
```

`'a`读为`生命周期a`, 一个函数可以在`<>`之间有泛型参数, 生命周期也是其中一种, 我们在参数列表中使用生命周期的方式为:

```rust
...(x: &'a i32)

...(x: &'a mut i32)
```

#### 在struct中

当你在处理结构体时你也需要显式的生命周期

```rust
struct Foo<'a> {
    x: &'a i32
}


fn main() {
    let y = &5;
    let f = Foo{ x: y };
    println!("{}", f.x)
}

// 当结构体使用引用时, 需要显式生命周期
```

#### impl块

```rust
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> i32 { self.x + 1 }
}

fn main() {
    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.
    let f = Foo { x: y };

    println!("x fn is: {}", f.x()); // 6
    println!("x is: {}", f.x); // 5
}
```

#### 多个生命周期

```rust
fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
#    x
# }

// x和y有不同的有效的作用域, 返回值和x有相同的生命周期
```

#### 理解作用域

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let x;                    // -+ `x` comes into scope.
                              //  |
    {                         //  |
        let y = &5;           // ---+ `y` comes into scope.
        let f = Foo { x: y }; // ---+ `f` comes into scope.
        x = &f.x;             //  | | This causes an error. x is no long live 
    }                         // ---+ `f` and y go out of scope.
                              //  |
    println!("{}", x);        //  |
}                             // -+ `x` goes out of scope.
```

#### 'static

叫做static的生命周期是特殊的。它代表某样东西具有横跨整个程序的生命周期。

```rust
let x: &'static str = "Hello, world.";

static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

### 4.11 可变性


```rust
let mut x = 5;

x = 6; // No problem!
```

当然你也可以用`&x`来创建一个引用, 不过如果你想要使用这个引用来改变它的值, 将会需要一个可变引用

```rust
let mut x = 5;
let y = &mut x;
```

y是一个（指向）可变引用的不可变绑定，它意味着你不能把y与其它变量绑定（y = &mut z），不过y可以用来把x绑定到别的值上（*y = 5）。一个微妙的区别。


#### 内部可变性 VS 外部可变性 (interior vs exterior mutability)


```rust
use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();
```

当我们调用clone()时，Arc<T>需要更新引用计数。然而你并未使用任何mut，x是一个不可变绑定，并且我们也没有取得&mut 5或者什么。那么发生了什么呢？

为了解释这些，我们不得不回到Rust指导哲学的核心，内存安全，和Rust用以保证它的机制，[所有权](Ownership 所有权)系统，和更具体的[借用](Borrow and AsRef Borrow 和 AsRef.md#borrow)：

你可以拥有这两种类型借用的其中一个，但不能同时拥有：

- 拥有 1 个或多个不可变引用（&T）
- 只有 1 个可变引用（&mut T）

因此，这就是“不可变性”的真正定义：当有两个引用指向同一事物是安全的吗？在Arc<T>的情况下，是安全的：改变完全包含在结构自身内部。它并不面向用户。为此，`它用clone()分配&T`。如果分配&mut T的话，那么，这将会是一个问题。

#### 字段级别可变性 Field-level mutability

结构体的可变性位于它的绑定上

```rust
struct Point {
    x: i32,
    y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

```

当然可以使用`Cell<T>`来模拟字段级别的可变性

```rust
use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell<i32>,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!("y: {:?}", point.y);
```

### 4.12 结构体

可以借助`&mut`指针, 来增加类型的可变性

```rust
struct Point {
    x: i32,
    y: i32,
}

struct PointRef<'a> {
    x: &'a mut i32,
    y: &'a mut i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    {
        let r = PointRef { x: &mut point.x, y: &mut point.y };

        *r.x = 5;
        *r.y = 6;
    }

    assert_eq!(5, point.x);
    assert_eq!(6, point.y);
}
```

#### 更新语法 updated syntax

```rust
struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
```

#### 元组结构体

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

也有类似es6的解构方法:

```rust
# struct Color(i32, i32, i32);
# struct Point(i32, i32, i32);
# let black = Color(0, 0, 0);
# let origin = Point(0, 0, 0);
let black_r = black.0;
let Point(_, origin_y, origin_z) = origin;
```

#### 类单元结构体 Unit-like structs

你可以定义一个没有任何成员的结构体

```rust
struct Electron {} // Use empty braces...
struct Proton;     // ...or just a semicolon.

// Use the same notation when creating an instance.
let x = Electron {};
let y = Proton;
let z = Electron; // Error
```

### 枚举

```rust
# enum Message {
#     Move { x: i32, y: i32 },
# }
let x: Message = Message::Move { x: 3, y: 4 };

enum BoardGameTurn {
    Move { squares: i32 },
    Pass,
}

let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };
```

#### 构造器作为函数

```rust
# enum Message {
# Write(String),
# }

let v = vec!["Hello".to_string(), "World".to_string()];

let v1: Vec<Message> = v.into_iter().map(Message::Write).collect();
```

### 4.14 匹配

```rust
let x = 5;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    4 => println!("four"),
    5 => println!("five"),
    _ => println!("something else"), // _ 为必须的, 不可省略
}
```

#### 匹配枚举 Matching on enums

```rust
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit => quit(),
        Message::ChangeColor(r, g, b) => change_color(r, g, b),
        Message::Move { x, y: new_name_for_y } => move_cursor(x, new_name_for_y),
        Message::Write(s) => println!("{}", s),
    };
}
```

### 4.15 模式

```rust
let x = 1;

match x {
    y => println!("x: {} y: {}", x, y),
}

// print x: 1 y: 1
```

#### 多重模式 multiple patterns

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

#### 解构 destructuring

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { x, .. } => println!("x is {}", x),
}
```

#### 忽略绑定 Ignoring bindings

```rust
# let some_value: Result<i32, &'static str> = Err("There was an error");
match some_value {
    Ok(value) => println!("got a value: {}", value),
    Err(_) => println!("an error occurred"),
}

let tuple = (5, String::from("five"));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!("Tuple is: {:?}", tuple);
```

任何临时变量将会在语句结束时立刻被释放

```rust
// Here, the String created will be dropped immediately, as it’s not bound:

let _ = String::from("  hello  ").trim();
```

你也可以模式中用`..`来忽略多个值

```rust
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) => println!("Got a tuple!"),
    OptionalTuple::Missing => println!("No such luck."),
}
```

#### ref和ref mut

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r), // Got a reference to 5
}

// match中的r是&i32类型的

let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

#### 范围

```rust
let x = '💅';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

#### 绑定

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}

// 需要确保名字在每个模式的每一部分都绑定
```

#### 守卫

```rust
let x = 4;
let y = false;

match x {
    4 | 5 if y => println!("yes"),
    _ => println!("no"),
}
```

### 4.16 方法语法


```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!("{}", c.area());
}
```

同时&self有3中变体: `self`, `&self`和`&mut self`

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&self) {
       println!("taking self by reference!");
    }

    fn mutable_reference(&mut self) {
       println!("taking self by mutable reference!");
    }

    fn takes_ownership(self) {
       println!("taking ownership of self!");
    }
}
```

#### 关联函数 Associated functions

我们可以定义一个不带self参数的关联函数

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

fn main() {
    let c = Circle::new(0.0, 0.0, 2.0);
}
```

#### 创建者模式 Builder pattern

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl CircleBuilder {
    fn new() -> CircleBuilder {
        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
    }

    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {
        self.x = coordinate;
        self
    }

    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {
        self.y = coordinate;
        self
    }

    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn finalize(&self) -> Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

fn main() {
    let c = CircleBuilder::new()
                .x(1.0)
                .y(2.0)
                .radius(2.0)
                .finalize();

    println!("area: {}", c.area());
    println!("x: {}", c.x);
    println!("y: {}", c.y);
}
```

### 4.17 字符串

rust主要有两种字符串类型: `String`和`&str`

#### &str

这叫做字符串片段, 字符串常量是`&'static str`

```rust
let greeting = "Hello"
```

> 折行

```rust
let s = "foo
    bar";

assert_eq!("foo\n    bar", s);

let s = "foo\
    bar";

assert_eq!("foobar", s);
```

#### String

String通常通过一个字符串片段调用`to_string`方法转换而来

```rust
let mut s = "Hello".to_string(); // mut s: String
println!("{}", s);

s.push_str(", world.");
println!("{}", s);
```

String可以通过`&`转化为`&str`, 成本很小, 但是从&str转化为String设计到内存分配, 没有这样做的必要

#### 索引

因为字符串是有效UTF-8编码的, 不支持索引

```rust
let s = "hello";

println!("The first letter of s is {}", s[0]); // ERROR!!!

// 正确的做法

let hachiko = "忠犬ハチ公";

for b in hachiko.as_bytes() {
    print!("{}, ", b); // 229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
}

println!("");

for c in hachiko.chars() {
    print!("{}, ", c); // 忠, 犬, ハ, チ, 公,
}

println!("");
```

#### 切片

```rust
let dog = "hachiko";
let hachi = &dog[0..5];

// 但需要主要的是这里是字节偏移, 而不是字节偏移, 所以下面的代码会失败
let dog = "忠犬ハチ公";
let hachi = &dog[0..2];
```

#### 连接 concatenation

String可以直接在后面拼接上&str

```rust
let hello = "Hello ".to_string();
let world = "world!";

let hello_world = hello + world;
```

String与String的拼接需要加上&连接

```rust
let hello = "Hello ".to_string();
let world = "world!".to_string();

let hello_world = hello + &world;
```

### 4.18 泛型

#### 泛型结构体

```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
#
impl<T> Point<T> {
    fn swap(&mut self) {
        std::mem::swap(&mut self.x, &mut self.y);
    }
}
```

### 4.19 Traits

traits是一个告诉Rust编译器一个类型必须提供哪些功能的语言特性

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&self) -> f64;

    fn is_larger(&self, &Self) -> bool;
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }

    fn is_larger(&self, other: &Self) -> bool {
        self.area() > other.area()
    }
}
```

`Self`可以被用在类型标记中标识被作为参数传递的实现了这个trait的类型的一个实例


#### 泛型函数的trait bound

```rust
# trait HasArea {
#     fn area(&self) -> f64;
# }
fn print_area<T: HasArea>(shape: T) {
    println!("This shape has an area of {}", shape.area());
}
```

`<T: HasArea>`语法是指`any type that implements the HasArea trait`（任何实现了HasAreatrait的类型）。

#### 泛型结构体的trait bound

```rust
struct Rectangle<T> {
    x: T,
    y: T,
    width: T,
    height: T,
}

impl<T: PartialEq> Rectangle<T> {
    fn is_square(&self) -> bool {
        self.width == self.height
    }
}

fn main() {
    let mut r = Rectangle {
        x: 0,
        y: 0,
        width: 47,
        height: 47,
    };

    assert!(r.is_square());

    r.height = 42;
    assert!(!r.is_square());
}
```

#### 实现trait的原则

你可以在任何类型上实现一个trait, 比如`f32`

```rust
trait ApproxEqual {
    fn approx_equal(&self, other: &Self) -> bool;
}
impl ApproxEqual for f32 {
    fn approx_equal(&self, other: &Self) -> bool {
        // Appropriate for `self` and `other` being close to 1.0.
        (self - other).abs() <= ::std::f32::EPSILON
    }
}

println!("{}", 1.0.approx_equal(&1.00000001));
```

#### 多trait bound

可以通过`+`来添加多个trait

```rust
use std::fmt::Debug;

fn foo<T: Clone + Debug>(x: T) {
    x.clone();
    println!("{:?}", x);
}
```

#### where从句

用于优化代码风格

```rust
use std::fmt::Debug;

fn bar<T, K>(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!("{:?}", y);
}
```

#### 继承

实现一个trait提要求实现另一个trait

```rust
# trait Foo {
#     fn foo(&self);
# }
# trait FooBar : Foo {
#     fn foobar(&self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&self) { println!("foo"); }
}

impl FooBar for Baz {
    fn foobar(&self) { println!("foobar"); }
}

// error: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]
```

#### Deriving

实现像Debug和Default这样的trait是没有意义的, 所以rust提供了一个属性来允许rust为我们自动实现trait

```rust
#[derive(Debug)]
struct Foo;

fn main() {
    println!("{:?}", Foo);
}
```

### 4.20 Drop

为Rust标准库提供的trait, 当一个值离开作用域后运行, 但是需要注意的是, 执行顺序和申明顺序相反

```rust
struct Firework {
    strength: i32,
}

impl Drop for Firework {
    fn drop(&mut self) {
        println!("BOOM times {}!!!", self.strength);
    }
}

fn main() {
    let firecracker = Firework { strength: 1 };
    let tnt = Firework { strength: 100 };
}

// 100
// 1
```

### 4.21 if let

if let允许你合并if和let来减少特定类型模式匹配的开销。

```rust
# let option = Some(5);
# fn foo(x: i32) { }
if option.is_some() {
    let x = option.unwrap();
    foo(x);
}

# let option = Some(5);
# fn foo(x: i32) { }
match option {
    Some(x) => { foo(x) },
    None => {},
}
```

但是上面的方案都不是特别优雅

```rust
# let option = Some(5);
# fn foo(x: i32) { }
if let Some(x) = option {
    foo(x);
}
```

#### while let

```rust
let mut v = vec![1, 3, 5, 7, 11];
loop {
    match v.pop() {
        Some(x) =>  println!("{}", x),
        None => break,
    }
}

// 优雅
let mut v = vec![1, 3, 5, 7, 11];
while let Some(x) = v.pop() {
    println!("{}", x);
}
```

### 4.22 trait对象

当涉及到多态的代码时, 我们需要一个机制来决定哪个具体的版本应该得到执行。这叫做“分发”（dispatch）。大体上有两种形式的分发：静态分发和动态分发。虽然 Rust 喜欢静态分发，不过它也提供了一个叫做“trait 对象”的机制来支持动态分发。

```rust
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }
fn do_something<T: Foo>(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something(x);
    do_something(y);
}
```

#### 静态分发

上面的代码, 在编译时就会被优化为

```rust
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something_u8(x);
    do_something_string(y);
}
```

但是同时也引入了新的问题, `代码膨胀 code bloat`

#### 动态分发

Rust 通过一个叫做“trait 对象”的功能提供动态分发。比如说`&Foo、Box<Foo>`这些就是trait对象。它们是一些值，值中储存实现了特定 trait 的任意类型。它的具体类型只能在运行时才能确定。

从一些实现了特定trait的类型的指针中，可以从通过转型(casting)（例如，`&x as &Foo`）或者强制转型(coercing it)（例如，把&x当做参数传递给一个接收&Foo类型的函数）来取得trait对象。

```rust
// 转型casting
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }

fn do_something(x: &Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&x as &Foo);
}

// 强制类型 by concercing
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }

fn do_something(x: &Foo) {
    x.method();
}

fn main() {
    let x = "Hello".to_string();
    do_something(&x);
}
```

虽然没有导致代码膨胀, 但是因为调用了虚函数, 会带来更大的运行时开销, 也会大大阻止任何内联以及相关优化的进行

#### 为什么用指针

rust默认不适用指针来存放数据, 因此类型有着不同的大小, 在编译时知道值的大小, 以及了解把值作为参数传递给函数, 值在栈上移动, 值在堆上分配或者释放并存储等情况

用指针来储存值意味着当我们使用 trait 对象时值的大小（size）是无关的，只与指针的大小（size）有关。

#### 表现

可以在一个 trait 对象上通过一个特殊的函数指针的记录调用的特性函数通常叫做“虚函数表”（由编译器创建和管理）。

```rust
# mod foo {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
# }
```

一个trait对象就像包含一个`数据`指针和`虚函数表`指针的&Foo

数据指针指向 trait 对象保存的数据（某个未知的类型T），和一个虚表指针指向对应T的Foo实现的虚函数表。

一个虚表本质上是一个函数指针的结构体，指向每个函数实现的具体机器码。一个像trait_object.method()的函数调用会从虚表中取出正确的指针然后进行一个动态调用。例如：

```rust
struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -> String,
}

// u8:

fn call_method_on_u8(x: *const ()) -> String {
    // The compiler guarantees that this function is only called
    // with `x` pointing to a u8.
    let byte: &u8 = unsafe { &*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 1,
    align: 1,

    // Cast to a function pointer:
    method: call_method_on_u8 as fn(*const ()) -> String,
};


// String:

fn call_method_on_String(x: *const ()) -> String {
    // The compiler guarantees that this function is only called
    // with `x` pointing to a String.
    let string: &String = unsafe { &*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    // Values for a 64-bit computer, halve them for 32-bit ones
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -> String,
};
```

#### 对象安全

并不是所有 trait 都可以被用来作为一个 trait 对象。例如，vector 实现了Clone，不过如果我们尝试创建一个 trait 对象：

```rust
let v = vec![1, 2, 3];
let o = &v as &Clone;

error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &v as &Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &v as &Clone;
```

错误表明Clone并不是“对象安全的（object-safe）”。只有对象安全的 trait 才能成为 trait 对象。一个对象安全的 trait 需要如下两条为真：

- trait 并不要求Self: Sized
- 所有的方法是对象安全的

那么什么让一个方法是对象安全的呢？每一个方法必须要求Self: Sized或者如下所有：

- 必须没有任何类型参数
- 必须不使用Self
好的。如你所见，几乎所有的规则都谈到了Self。一个直观的理解是“除了特殊情况，**`如果你的 trait 的方法使用了Self，它就不是对象安全的”。`**

### 4.23 闭包

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```

```rust

```