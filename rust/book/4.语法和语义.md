### 4.2 å‡½æ•°

#### è¡¨è¾¾å¼ VS è¯­å¥

Rustä¸»è¦æ˜¯ä¸€ä¸ªåŸºäºè¡¨è¾¾å¼çš„è¯­è¨€, åªæœ‰ä¸¤ç§è¯­å¥, å…¶ä»–ä¸€åˆ‡éƒ½æ˜¯è¡¨è¾¾å¼

```rust
fn add_one(x: i32) -> i32 {
  x + 1
}

// æ­¤å¤„å¦‚æœåŠ ä¸Šsemicolon, åˆ™ä¸ä¼šæ­£å¸¸è¿”å›, ä¼šè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªè¯­å¥, è€Œè¡¨è¾¾å¼åˆ™ä¼šè¿”å›ä¸€ä¸ªå€¼, è¿™æ‰æ˜¯æ¨èçš„å†™æ³•
```

#### diverging function å‘æ•£å‡½æ•°

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
// ç±»å‹throwä¸€ä¸ªerror
```

#### å‡½æ•°æŒ‡é’ˆ

```rust
fn plus_one(i: i32) -> i32 {
  i + 1
}

let f: fn(i32) -> i32 = plus_one

let result = f(5)
```

### 4.3 primitive types åŸç”Ÿç±»å‹

1. å¸ƒå°”å‹
2. char
3. æ•°å­—ç±»å‹ `i8`, `i16`, `u16`, `f64`, `isize`
4. æ•°ç»„

```rust
let a = [0; 20] // a: [i32; 20], åˆå§‹åŒ–äº†å«æœ‰20ä¸ª0çš„æ•°ç»„
```

> åˆ‡ç‰‡ slices

```rust
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // A slice containing all of the elements in `a`.
let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.
```

5. str æœ€åŸå§‹çš„å­—ç¬¦ä¸²ç±»å‹, ä¸ºä¸å®šé•¿ç±»å‹
6. å…ƒç»„ tuples

> å…ƒç»„çš„ç´¢å¼•

```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

7. å‡½æ•°

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i: 32) -> i32 = foo;
```

### Ifè¯­å¥

å› ä¸ºifæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼, æ‰€ä»¥å¯ä»¥è¿™ä¹ˆå†™

```rust
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
```

### loopå¾ªç¯

æä¾›äº†ä¸‰ç§æ–¹æ³•æ¥è¿›è¡Œä¸€äº›è¿­ä»£æ‰åš, åˆ†åˆ«ä¸º`loop`, `while`ä»¥åŠ`for`

1. loop

è¿™ä¸ªä¸ºæ— é™å¾ªç¯, ä½¿ç”¨`break`æ¥ç»ˆæ­¢å¾ªç¯

2. while

```rust
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!("{}", x);

    if x % 5 == 0 {
        done = true;
    }
}
```

3. for

```rust
for x in 0..10 {
    println!("{}", x); // x: i32
}

// æ›´æŠ½è±¡çš„å½¢å¼ è¿™ä¸ªè¡¨è¾¾å¼æ˜¯ä¸€ä¸ªè¿­ä»£å™¨
for var in expression {
    code
}
```

4. Enumerateæ–¹æ³•

å½“ä½ æƒ³çŸ¥é“å·²ç»å¾ªç¯äº†å¤šå°‘æ¬¡çš„æ—¶å€™, éœ€è¦ä½¿ç”¨`.enumerate()å‡½æ•°`

```rust
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}
```

5. å¾ªç¯æ ‡ç­¾ Loop labels

```rust
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}
```

### 4.7 Vectors

å®ç°çš„æ ‡å‡†åº“ä¸ºVec<T>, ä¹Ÿå¯ä»¥ä½¿ç”¨vec!å®æ¥åˆ›å»ºå®ƒ

```rust
let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>
let v = vec![0; 10]; // ten zeroes
```

#### è®¿é—®å…ƒç´ 

å€¼å¾—æ³¨æ„çš„æ˜¯, å¿…é¡»ä½¿ç”¨`usize`ç±»å‹çš„å€¼è¿›è¡Œç´¢å¼•

```rust
let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// Works:
v[i];

// Doesnâ€™t:
v[j];
```

ä¸ºäº†ä¸å‡ºç°out of bounds error, æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`get`æˆ–è€…`get_mut`æ¥è·å–å…ƒç´ , è‹¥ç´¢å¼•æ— æ•ˆçš„è¯, ä¼šè¿”å›None

```rust
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}
```

#### iterate

```rust
let mut v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("A reference to {}", i);
}

for i in &mut v {
    println!("A mutable reference to {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}

// éœ€è¦æ³¨æ„çš„æ˜¯ æœ€åä¸€ä¸ªæ–¹æ³•å°†ä¸èƒ½å†æ¬¡ä½¿ç”¨åŒæ ·çš„æ–¹æ³•éå†vector, å…¶ä½™ä¸¤ç§ä½¿ç”¨å¼•ç”¨çš„æ–¹æ³•å°±ä¸ä¼šå‡ºç°è¿™æ ·çš„é—®é¢˜
```

### 4.8 æ‰€æœ‰æƒ

rustæ³¨é‡å®‰å…¨å’Œé€Ÿåº¦, é€šè¿‡å¾ˆå¤šzero-cost abstractions é›¶å¼€é”€æŠ½è±¡æ¥å®ç°è¿™äº›ç›®æ ‡, åˆ†æéƒ½åœ¨ç¼–è¯‘æ—¶å®Œæˆ, ä¸éœ€è¦å†è¿è¡Œæ—¶ä¸ºè¿™äº›åŠŸèƒ½ä»˜å‡ºä»»ä½•å¼€é”€

#### æ‰€æœ‰æƒ ownership

Rust ä¸­çš„[å˜é‡ç»‘å®š](Variable Bindings)æœ‰ä¸€ä¸ªå±æ€§ï¼šå®ƒä»¬æœ‰å®ƒä»¬æ‰€ç»‘å®šçš„çš„å€¼çš„æ‰€æœ‰æƒã€‚è¿™æ„å‘³ç€å½“ä¸€ä¸ªç»‘å®šç¦»å¼€ä½œç”¨åŸŸï¼Œå®ƒä»¬ç»‘å®šçš„èµ„æºå°±ä¼šè¢«é‡Šæ”¾ã€‚ä¾‹å¦‚ï¼š

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

å½“è¿›å…¥ä½œç”¨åŸŸæ—¶, ä¸€ä¸ªvectoråœ¨æ ˆä¸Šè¢«åˆ›å»º, å¹¶åœ¨å †ä¸Šä¸ºå®ƒçš„3ä¸ªå…ƒç´ åˆ†é…äº†ç©ºé—´, ç¦»å¼€ä½œç”¨åŸŸä»¥å, rustå°†ä¼šæ¸…ç†æ‰ä¸vectorç›¸å…³çš„ä¸€åˆ‡, ç”šè‡³æ˜¯å †ä¸Šçš„åˆ†é…çš„å†…å­˜


#### ç§»åŠ¨è¯­ä¹‰ move semantics

ç„¶è€Œè¿™é‡Œæœ‰æ›´å·§å¦™çš„åœ°æ–¹ï¼šRust ç¡®ä¿äº†å¯¹äºä»»ä½•ç»™å®šçš„èµ„æºéƒ½æ­£å¥½ï¼ˆåªï¼‰æœ‰ä¸€ä¸ªç»‘å®šä¸ä¹‹å¯¹åº”ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ª vectorï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒèµ‹äºˆå¦å¤–ä¸€ä¸ªç»‘å®šï¼š

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]); // error
```

ä¸‹é¢çš„ä¾‹å­ä¼šå‡ºç°ä¸€æ ·çš„é”™è¯¯, æˆ‘ä»¬æŠŠæ‰€æœ‰æƒè½¬ç§»ç»™äº†åˆ«çš„ç»‘å®šæ—¶, æˆ‘ä»¬è¯´æˆ‘ä»¬ç§»åŠ¨äº†æˆ‘ä»¬å¼•ç”¨çš„å€¼

```rust
fn take(v: Vec<i32>) {
    // What happens here isnâ€™t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

#### Copyç±»å‹

æˆ‘ä»¬å·²ç»çŸ¥é“äº†å½“æ‰€æœ‰æƒè¢«è½¬ç§»ç»™å¦ä¸€ä¸ªç»‘å®šä»¥åï¼Œä½ ä¸èƒ½å†ä½¿ç”¨åŸå§‹ç»‘å®šã€‚ç„¶è€Œï¼Œæœ‰ä¸€ä¸ªtraitä¼šæ”¹å˜è¿™ä¸ªè¡Œä¸ºï¼Œå®ƒå«åšCopyã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºåˆ° traitï¼Œä¸è¿‡ç›®å‰ï¼Œä½ å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä¸ºç‰¹å®šç±»å‹å¢åŠ é¢å¤–è¡Œä¸ºçš„æ ‡è®°ã€‚ä¾‹å¦‚ï¼š

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);

// i32å¹¶æ²¡æœ‰æŒ‡å‘å…¶ä»–æ•°æ®çš„æŒ‡é’ˆ, å¯¹ä»–çš„æ‹·è´æ˜¯ä¸€ä¸ªå®Œæ•´çš„æ‹·è´
```

æ‰€æœ‰åŸºæœ¬ç±»å‹éƒ½å®ç°äº†`copy trait`, ä¸éµå¾ªæ‰€æœ‰æƒè§„åˆ™


### 4.9 å¼•ç”¨ä¸å€Ÿç”¨

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

// can not use v1 v2 again
```

ç„¶åä¸Šé¢çš„å¹¶ä¸æ˜¯rustç†æƒ³çš„ä»£ç 

```rust
fn main() {
    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed.
    fn sum_vec(v: &Vec<i32>) -> i32 {
        return v.iter().fold(0, |a, &b| a + b);
    }
    // Borrow two vectors and sum them.
    // This kind of borrowing does not allow mutation through the borrowed reference.
    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
        // Do stuff with `v1` and `v2`.
        let s1 = sum_vec(v1);
        let s2 = sum_vec(v2);
        // Return the answer.
        s1 + s2
    }

    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5, 6];

    let answer = foo(&v1, &v2);
    println!("{}", answer);
}
```

å¼•ç”¨æ˜¯ä¸å¯èƒ½å˜çš„, æ„å‘³ç€åœ¨fooå½“ä¸­, å‘é‡å®Œå…¨ä¸èƒ½è¢«æ”¹å˜

```rust
fn foo(v: &Vec<i32>) {
     v.push(5); // cannot borrow immutable borrowed content `*v` as mutable
}

let v = vec![];

foo(&v);
```

#### &mut å¼•ç”¨

è¿™æ˜¯ç¬¬äºŒç§ç±»å‹çš„å¼•ç”¨: &mut T, ä¸€ä¸ªå¯å˜å¼•ç”¨å…è®¸ä½ æ”¹å˜ä½ å€Ÿç”¨çš„èµ„æº

```rust
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

#### è§„åˆ™

1. ä»»ä½•å€Ÿç”¨å¿…é¡»ä½äºæ¯”æ‹¥æœ‰è€…æ›´å°çš„ä½œç”¨åŸŸ
2. å¯¹äºåŒä¸€ä¸ªèµ„æºçš„å€Ÿç”¨, ä»¥ä¸‹çš„æƒ…å†µä¸èƒ½åŒæ—¶å‡ºç°åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸‹: ç®€å•çš„è¯´å°±æ˜¯åŒä¸€ä¸ªä½œç”¨åŸŸä¸‹ä¸èƒ½åŒæ—¶å­˜åœ¨ä¸å¯å˜å’Œå¯å˜çš„å¼•ç”¨
- 1ä¸ªæˆ–è€…å¤šä¸ªä¸å¯å˜å¼•ç”¨(&T)
- å”¯ä¸€1ä¸ªå¯å˜å¼•ç”¨(&mut T)

```rust
fn main() {
    let mut x = 5;

    let y = &mut x;    // -+ &mut borrow of `x` starts here.
                       //  |
    *y += 1;           //  |
                       //  |
    println!("{}", x); // -+ - Try to borrow `x` here.
}                      // -+ &mut borrow of `x` ends here.
```

è§£å†³æ–¹æ³•ä¸ºä¸Šé¢çš„ä»£ç , æ·»åŠ å¤§æ‹¬å·å³å¯

#### é‡Šæ”¾åä½¿ç”¨

å¼•ç”¨å¿…é¡»ä¸å®ƒå¼•ç”¨çš„å€¼å­˜æ´»çš„ä¸€æ ·é•¿

```rust
let y: &i32;
let x = 5;
y = &x;

println!("{}", y);

// error: x does not live long enough
```

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­, yåœ¨xä¹‹å‰è¢«ç”³æ˜, æ‰€ä»¥yçš„ç”Ÿå‘½å‘¨æœŸæ›´é•¿, è¿™æ˜¯ä¸è¢«å…è®¸çš„

### 4.10 ç”Ÿå‘½å‘¨æœŸ Lifetimes

æ€è€ƒä¸‹é¢çš„ä¾‹å­:

```rust
fn skip_prefix(line: &str, prefix: &str) -> &str {
    // ...
#   line
}

let line = "lang:en=Hello World!";
let lang = "en";

let v;
{
    let p = format!("lang:{}=", lang);  // -+ `p` comes into scope.
    v = skip_prefix(line, p.as_str());  //  |
}                                       // -+ `p` goes out of scope.
println!("{}", v);
```

æˆ‘ä»¬éœ€è¦ä¿è¯å€Ÿç”¨çš„å¼•ç”¨åœ¨ä½¿ç”¨çš„æ—¶å€™æ²¡æœ‰è¢«é‡Šæ”¾, æ‰€ä»¥ä¸Šé¢çš„ä¾‹å­rustæ˜¯ä¸ä¼šç¼–è¯‘æˆåŠŸçš„è¯, ä¸ºäº†æˆåŠŸæˆ‘ä»¬éœ€è¦å¼•å…¥å¼•ç”¨ç”Ÿå‘½å‘¨æœŸä¿¡æ¯

```rust
fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {
    // ...
#   line
}
```

`'a`è¯»ä¸º`ç”Ÿå‘½å‘¨æœŸa`, ä¸€ä¸ªå‡½æ•°å¯ä»¥åœ¨`<>`ä¹‹é—´æœ‰æ³›å‹å‚æ•°, ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯å…¶ä¸­ä¸€ç§, æˆ‘ä»¬åœ¨å‚æ•°åˆ—è¡¨ä¸­ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçš„æ–¹å¼ä¸º:

```rust
...(x: &'a i32)

...(x: &'a mut i32)
```

#### åœ¨structä¸­

å½“ä½ åœ¨å¤„ç†ç»“æ„ä½“æ—¶ä½ ä¹Ÿéœ€è¦æ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸ

```rust
struct Foo<'a> {
    x: &'a i32
}


fn main() {
    let y = &5;
    let f = Foo{ x: y };
    println!("{}", f.x)
}

// å½“ç»“æ„ä½“ä½¿ç”¨å¼•ç”¨æ—¶, éœ€è¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ
```

#### implå—

```rust
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> i32 { self.x + 1 }
}

fn main() {
    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.
    let f = Foo { x: y };

    println!("x fn is: {}", f.x()); // 6
    println!("x is: {}", f.x); // 5
}
```

#### å¤šä¸ªç”Ÿå‘½å‘¨æœŸ

```rust
fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
#    x
# }

// xå’Œyæœ‰ä¸åŒçš„æœ‰æ•ˆçš„ä½œç”¨åŸŸ, è¿”å›å€¼å’Œxæœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
```

#### ç†è§£ä½œç”¨åŸŸ

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let x;                    // -+ `x` comes into scope.
                              //  |
    {                         //  |
        let y = &5;           // ---+ `y` comes into scope.
        let f = Foo { x: y }; // ---+ `f` comes into scope.
        x = &f.x;             //  | | This causes an error. x is no long live 
    }                         // ---+ `f` and y go out of scope.
                              //  |
    println!("{}", x);        //  |
}                             // -+ `x` goes out of scope.
```

#### 'static

å«åšstaticçš„ç”Ÿå‘½å‘¨æœŸæ˜¯ç‰¹æ®Šçš„ã€‚å®ƒä»£è¡¨æŸæ ·ä¸œè¥¿å…·æœ‰æ¨ªè·¨æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸã€‚

```rust
let x: &'static str = "Hello, world.";

static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

### 4.11 å¯å˜æ€§


```rust
let mut x = 5;

x = 6; // No problem!
```

å½“ç„¶ä½ ä¹Ÿå¯ä»¥ç”¨`&x`æ¥åˆ›å»ºä¸€ä¸ªå¼•ç”¨, ä¸è¿‡å¦‚æœä½ æƒ³è¦ä½¿ç”¨è¿™ä¸ªå¼•ç”¨æ¥æ”¹å˜å®ƒçš„å€¼, å°†ä¼šéœ€è¦ä¸€ä¸ªå¯å˜å¼•ç”¨

```rust
let mut x = 5;
let y = &mut x;
```

yæ˜¯ä¸€ä¸ªï¼ˆæŒ‡å‘ï¼‰å¯å˜å¼•ç”¨çš„ä¸å¯å˜ç»‘å®šï¼Œå®ƒæ„å‘³ç€ä½ ä¸èƒ½æŠŠyä¸å…¶å®ƒå˜é‡ç»‘å®šï¼ˆy = &mut zï¼‰ï¼Œä¸è¿‡yå¯ä»¥ç”¨æ¥æŠŠxç»‘å®šåˆ°åˆ«çš„å€¼ä¸Šï¼ˆ*y = 5ï¼‰ã€‚ä¸€ä¸ªå¾®å¦™çš„åŒºåˆ«ã€‚


#### å†…éƒ¨å¯å˜æ€§ VS å¤–éƒ¨å¯å˜æ€§ (interior vs exterior mutability)


```rust
use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();
```

å½“æˆ‘ä»¬è°ƒç”¨clone()æ—¶ï¼ŒArc<T>éœ€è¦æ›´æ–°å¼•ç”¨è®¡æ•°ã€‚ç„¶è€Œä½ å¹¶æœªä½¿ç”¨ä»»ä½•mutï¼Œxæ˜¯ä¸€ä¸ªä¸å¯å˜ç»‘å®šï¼Œå¹¶ä¸”æˆ‘ä»¬ä¹Ÿæ²¡æœ‰å–å¾—&mut 5æˆ–è€…ä»€ä¹ˆã€‚é‚£ä¹ˆå‘ç”Ÿäº†ä»€ä¹ˆå‘¢ï¼Ÿ

ä¸ºäº†è§£é‡Šè¿™äº›ï¼Œæˆ‘ä»¬ä¸å¾—ä¸å›åˆ°RustæŒ‡å¯¼å“²å­¦çš„æ ¸å¿ƒï¼Œå†…å­˜å®‰å…¨ï¼Œå’ŒRustç”¨ä»¥ä¿è¯å®ƒçš„æœºåˆ¶ï¼Œ[æ‰€æœ‰æƒ](Ownership æ‰€æœ‰æƒ)ç³»ç»Ÿï¼Œå’Œæ›´å…·ä½“çš„[å€Ÿç”¨](Borrow and AsRef Borrow å’Œ AsRef.md#borrow)ï¼š

ä½ å¯ä»¥æ‹¥æœ‰è¿™ä¸¤ç§ç±»å‹å€Ÿç”¨çš„å…¶ä¸­ä¸€ä¸ªï¼Œä½†ä¸èƒ½åŒæ—¶æ‹¥æœ‰ï¼š

- æ‹¥æœ‰ 1 ä¸ªæˆ–å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼ˆ&Tï¼‰
- åªæœ‰ 1 ä¸ªå¯å˜å¼•ç”¨ï¼ˆ&mut Tï¼‰

å› æ­¤ï¼Œè¿™å°±æ˜¯â€œä¸å¯å˜æ€§â€çš„çœŸæ­£å®šä¹‰ï¼šå½“æœ‰ä¸¤ä¸ªå¼•ç”¨æŒ‡å‘åŒä¸€äº‹ç‰©æ˜¯å®‰å…¨çš„å—ï¼Ÿåœ¨Arc<T>çš„æƒ…å†µä¸‹ï¼Œæ˜¯å®‰å…¨çš„ï¼šæ”¹å˜å®Œå…¨åŒ…å«åœ¨ç»“æ„è‡ªèº«å†…éƒ¨ã€‚å®ƒå¹¶ä¸é¢å‘ç”¨æˆ·ã€‚ä¸ºæ­¤ï¼Œ`å®ƒç”¨clone()åˆ†é…&T`ã€‚å¦‚æœåˆ†é…&mut Tçš„è¯ï¼Œé‚£ä¹ˆï¼Œè¿™å°†ä¼šæ˜¯ä¸€ä¸ªé—®é¢˜ã€‚

#### å­—æ®µçº§åˆ«å¯å˜æ€§ Field-level mutability

ç»“æ„ä½“çš„å¯å˜æ€§ä½äºå®ƒçš„ç»‘å®šä¸Š

```rust
struct Point {
    x: i32,
    y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

```

å½“ç„¶å¯ä»¥ä½¿ç”¨`Cell<T>`æ¥æ¨¡æ‹Ÿå­—æ®µçº§åˆ«çš„å¯å˜æ€§

```rust
use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell<i32>,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!("y: {:?}", point.y);
```

### 4.12 ç»“æ„ä½“

å¯ä»¥å€ŸåŠ©`&mut`æŒ‡é’ˆ, æ¥å¢åŠ ç±»å‹çš„å¯å˜æ€§

```rust
struct Point {
    x: i32,
    y: i32,
}

struct PointRef<'a> {
    x: &'a mut i32,
    y: &'a mut i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    {
        let r = PointRef { x: &mut point.x, y: &mut point.y };

        *r.x = 5;
        *r.y = 6;
    }

    assert_eq!(5, point.x);
    assert_eq!(6, point.y);
}
```

#### æ›´æ–°è¯­æ³• updated syntax

```rust
struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
```

#### å…ƒç»„ç»“æ„ä½“

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

ä¹Ÿæœ‰ç±»ä¼¼es6çš„è§£æ„æ–¹æ³•:

```rust
# struct Color(i32, i32, i32);
# struct Point(i32, i32, i32);
# let black = Color(0, 0, 0);
# let origin = Point(0, 0, 0);
let black_r = black.0;
let Point(_, origin_y, origin_z) = origin;
```

#### ç±»å•å…ƒç»“æ„ä½“ Unit-like structs

ä½ å¯ä»¥å®šä¹‰ä¸€ä¸ªæ²¡æœ‰ä»»ä½•æˆå‘˜çš„ç»“æ„ä½“

```rust
struct Electron {} // Use empty braces...
struct Proton;     // ...or just a semicolon.

// Use the same notation when creating an instance.
let x = Electron {};
let y = Proton;
let z = Electron; // Error
```

### æšä¸¾

```rust
# enum Message {
#     Move { x: i32, y: i32 },
# }
let x: Message = Message::Move { x: 3, y: 4 };

enum BoardGameTurn {
    Move { squares: i32 },
    Pass,
}

let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };
```

#### æ„é€ å™¨ä½œä¸ºå‡½æ•°

```rust
# enum Message {
# Write(String),
# }

let v = vec!["Hello".to_string(), "World".to_string()];

let v1: Vec<Message> = v.into_iter().map(Message::Write).collect();
```

### 4.14 åŒ¹é…

```rust
let x = 5;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    4 => println!("four"),
    5 => println!("five"),
    _ => println!("something else"), // _ ä¸ºå¿…é¡»çš„, ä¸å¯çœç•¥
}
```

#### åŒ¹é…æšä¸¾ Matching on enums

```rust
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit => quit(),
        Message::ChangeColor(r, g, b) => change_color(r, g, b),
        Message::Move { x, y: new_name_for_y } => move_cursor(x, new_name_for_y),
        Message::Write(s) => println!("{}", s),
    };
}
```

### 4.15 æ¨¡å¼

```rust
let x = 1;

match x {
    y => println!("x: {} y: {}", x, y),
}

// print x: 1 y: 1
```

#### å¤šé‡æ¨¡å¼ multiple patterns

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

#### è§£æ„ destructuring

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { x, .. } => println!("x is {}", x),
}
```

#### å¿½ç•¥ç»‘å®š Ignoring bindings

```rust
# let some_value: Result<i32, &'static str> = Err("There was an error");
match some_value {
    Ok(value) => println!("got a value: {}", value),
    Err(_) => println!("an error occurred"),
}

let tuple = (5, String::from("five"));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!("Tuple is: {:?}", tuple);
```

ä»»ä½•ä¸´æ—¶å˜é‡å°†ä¼šåœ¨è¯­å¥ç»“æŸæ—¶ç«‹åˆ»è¢«é‡Šæ”¾

```rust
// Here, the String created will be dropped immediately, as itâ€™s not bound:

let _ = String::from("  hello  ").trim();
```

ä½ ä¹Ÿå¯ä»¥æ¨¡å¼ä¸­ç”¨`..`æ¥å¿½ç•¥å¤šä¸ªå€¼

```rust
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) => println!("Got a tuple!"),
    OptionalTuple::Missing => println!("No such luck."),
}
```

#### refå’Œref mut

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r), // Got a reference to 5
}

// matchä¸­çš„ræ˜¯&i32ç±»å‹çš„

let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

#### èŒƒå›´

```rust
let x = 'ğŸ’…';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

#### ç»‘å®š

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}

// éœ€è¦ç¡®ä¿åå­—åœ¨æ¯ä¸ªæ¨¡å¼çš„æ¯ä¸€éƒ¨åˆ†éƒ½ç»‘å®š
```

#### å®ˆå«

```rust
let x = 4;
let y = false;

match x {
    4 | 5 if y => println!("yes"),
    _ => println!("no"),
}
```

### 4.16 æ–¹æ³•è¯­æ³•


```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!("{}", c.area());
}
```

åŒæ—¶&selfæœ‰3ä¸­å˜ä½“: `self`, `&self`å’Œ`&mut self`

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&self) {
       println!("taking self by reference!");
    }

    fn mutable_reference(&mut self) {
       println!("taking self by mutable reference!");
    }

    fn takes_ownership(self) {
       println!("taking ownership of self!");
    }
}
```

#### å…³è”å‡½æ•° Associated functions

æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªä¸å¸¦selfå‚æ•°çš„å…³è”å‡½æ•°

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

fn main() {
    let c = Circle::new(0.0, 0.0, 2.0);
}
```

#### åˆ›å»ºè€…æ¨¡å¼ Builder pattern

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl CircleBuilder {
    fn new() -> CircleBuilder {
        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
    }

    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {
        self.x = coordinate;
        self
    }

    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {
        self.y = coordinate;
        self
    }

    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn finalize(&self) -> Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

fn main() {
    let c = CircleBuilder::new()
                .x(1.0)
                .y(2.0)
                .radius(2.0)
                .finalize();

    println!("area: {}", c.area());
    println!("x: {}", c.x);
    println!("y: {}", c.y);
}
```

### 4.17 å­—ç¬¦ä¸²

rustä¸»è¦æœ‰ä¸¤ç§å­—ç¬¦ä¸²ç±»å‹: `String`å’Œ`&str`

#### &str

è¿™å«åšå­—ç¬¦ä¸²ç‰‡æ®µ, å­—ç¬¦ä¸²å¸¸é‡æ˜¯`&'static str`

```rust
let greeting = "Hello"
```

> æŠ˜è¡Œ

```rust
let s = "foo
    bar";

assert_eq!("foo\n    bar", s);

let s = "foo\
    bar";

assert_eq!("foobar", s);
```

#### String

Stringé€šå¸¸é€šè¿‡ä¸€ä¸ªå­—ç¬¦ä¸²ç‰‡æ®µè°ƒç”¨`to_string`æ–¹æ³•è½¬æ¢è€Œæ¥

```rust
let mut s = "Hello".to_string(); // mut s: String
println!("{}", s);

s.push_str(", world.");
println!("{}", s);
```

Stringå¯ä»¥é€šè¿‡`&`è½¬åŒ–ä¸º`&str`, æˆæœ¬å¾ˆå°, ä½†æ˜¯ä»&strè½¬åŒ–ä¸ºStringè®¾è®¡åˆ°å†…å­˜åˆ†é…, æ²¡æœ‰è¿™æ ·åšçš„å¿…è¦

#### ç´¢å¼•

å› ä¸ºå­—ç¬¦ä¸²æ˜¯æœ‰æ•ˆUTF-8ç¼–ç çš„, ä¸æ”¯æŒç´¢å¼•

```rust
let s = "hello";

println!("The first letter of s is {}", s[0]); // ERROR!!!

// æ­£ç¡®çš„åšæ³•

let hachiko = "å¿ çŠ¬ãƒãƒå…¬";

for b in hachiko.as_bytes() {
    print!("{}, ", b); // 229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
}

println!("");

for c in hachiko.chars() {
    print!("{}, ", c); // å¿ , çŠ¬, ãƒ, ãƒ, å…¬,
}

println!("");
```

#### åˆ‡ç‰‡

```rust
let dog = "hachiko";
let hachi = &dog[0..5];

// ä½†éœ€è¦ä¸»è¦çš„æ˜¯è¿™é‡Œæ˜¯å­—èŠ‚åç§», è€Œä¸æ˜¯å­—èŠ‚åç§», æ‰€ä»¥ä¸‹é¢çš„ä»£ç ä¼šå¤±è´¥
let dog = "å¿ çŠ¬ãƒãƒå…¬";
let hachi = &dog[0..2];
```

#### è¿æ¥ concatenation

Stringå¯ä»¥ç›´æ¥åœ¨åé¢æ‹¼æ¥ä¸Š&str

```rust
let hello = "Hello ".to_string();
let world = "world!";

let hello_world = hello + world;
```

Stringä¸Stringçš„æ‹¼æ¥éœ€è¦åŠ ä¸Š&è¿æ¥

```rust
let hello = "Hello ".to_string();
let world = "world!".to_string();

let hello_world = hello + &world;
```

### 4.18 æ³›å‹

#### æ³›å‹ç»“æ„ä½“

```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
#
impl<T> Point<T> {
    fn swap(&mut self) {
        std::mem::swap(&mut self.x, &mut self.y);
    }
}
```

### 4.19 Traits

traitsæ˜¯ä¸€ä¸ªå‘Šè¯‰Rustç¼–è¯‘å™¨ä¸€ä¸ªç±»å‹å¿…é¡»æä¾›å“ªäº›åŠŸèƒ½çš„è¯­è¨€ç‰¹æ€§

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&self) -> f64;

    fn is_larger(&self, &Self) -> bool;
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }

    fn is_larger(&self, other: &Self) -> bool {
        self.area() > other.area()
    }
}
```

`Self`å¯ä»¥è¢«ç”¨åœ¨ç±»å‹æ ‡è®°ä¸­æ ‡è¯†è¢«ä½œä¸ºå‚æ•°ä¼ é€’çš„å®ç°äº†è¿™ä¸ªtraitçš„ç±»å‹çš„ä¸€ä¸ªå®ä¾‹


#### æ³›å‹å‡½æ•°çš„trait bound

```rust
# trait HasArea {
#     fn area(&self) -> f64;
# }
fn print_area<T: HasArea>(shape: T) {
    println!("This shape has an area of {}", shape.area());
}
```

`<T: HasArea>`è¯­æ³•æ˜¯æŒ‡`any type that implements the HasArea trait`ï¼ˆä»»ä½•å®ç°äº†HasAreatraitçš„ç±»å‹ï¼‰ã€‚

#### æ³›å‹ç»“æ„ä½“çš„trait bound

```rust
struct Rectangle<T> {
    x: T,
    y: T,
    width: T,
    height: T,
}

impl<T: PartialEq> Rectangle<T> {
    fn is_square(&self) -> bool {
        self.width == self.height
    }
}

fn main() {
    let mut r = Rectangle {
        x: 0,
        y: 0,
        width: 47,
        height: 47,
    };

    assert!(r.is_square());

    r.height = 42;
    assert!(!r.is_square());
}
```

#### å®ç°traitçš„åŸåˆ™

ä½ å¯ä»¥åœ¨ä»»ä½•ç±»å‹ä¸Šå®ç°ä¸€ä¸ªtrait, æ¯”å¦‚`f32`

```rust
trait ApproxEqual {
    fn approx_equal(&self, other: &Self) -> bool;
}
impl ApproxEqual for f32 {
    fn approx_equal(&self, other: &Self) -> bool {
        // Appropriate for `self` and `other` being close to 1.0.
        (self - other).abs() <= ::std::f32::EPSILON
    }
}

println!("{}", 1.0.approx_equal(&1.00000001));
```

#### å¤štrait bound

å¯ä»¥é€šè¿‡`+`æ¥æ·»åŠ å¤šä¸ªtrait

```rust
use std::fmt::Debug;

fn foo<T: Clone + Debug>(x: T) {
    x.clone();
    println!("{:?}", x);
}
```

#### whereä»å¥

ç”¨äºä¼˜åŒ–ä»£ç é£æ ¼

```rust
use std::fmt::Debug;

fn bar<T, K>(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!("{:?}", y);
}
```

#### ç»§æ‰¿

å®ç°ä¸€ä¸ªtraitæè¦æ±‚å®ç°å¦ä¸€ä¸ªtrait

```rust
# trait Foo {
#     fn foo(&self);
# }
# trait FooBar : Foo {
#     fn foobar(&self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&self) { println!("foo"); }
}

impl FooBar for Baz {
    fn foobar(&self) { println!("foobar"); }
}

// error: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]
```

#### Deriving

å®ç°åƒDebugå’ŒDefaultè¿™æ ·çš„traitæ˜¯æ²¡æœ‰æ„ä¹‰çš„, æ‰€ä»¥rustæä¾›äº†ä¸€ä¸ªå±æ€§æ¥å…è®¸rustä¸ºæˆ‘ä»¬è‡ªåŠ¨å®ç°trait

```rust
#[derive(Debug)]
struct Foo;

fn main() {
    println!("{:?}", Foo);
}
```

### 4.20 Drop

ä¸ºRustæ ‡å‡†åº“æä¾›çš„trait, å½“ä¸€ä¸ªå€¼ç¦»å¼€ä½œç”¨åŸŸåè¿è¡Œ, ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯, æ‰§è¡Œé¡ºåºå’Œç”³æ˜é¡ºåºç›¸å

```rust
struct Firework {
    strength: i32,
}

impl Drop for Firework {
    fn drop(&mut self) {
        println!("BOOM times {}!!!", self.strength);
    }
}

fn main() {
    let firecracker = Firework { strength: 1 };
    let tnt = Firework { strength: 100 };
}

// 100
// 1
```

### 4.21 if let

if letå…è®¸ä½ åˆå¹¶ifå’Œletæ¥å‡å°‘ç‰¹å®šç±»å‹æ¨¡å¼åŒ¹é…çš„å¼€é”€ã€‚

```rust
# let option = Some(5);
# fn foo(x: i32) { }
if option.is_some() {
    let x = option.unwrap();
    foo(x);
}

# let option = Some(5);
# fn foo(x: i32) { }
match option {
    Some(x) => { foo(x) },
    None => {},
}
```

ä½†æ˜¯ä¸Šé¢çš„æ–¹æ¡ˆéƒ½ä¸æ˜¯ç‰¹åˆ«ä¼˜é›…

```rust
# let option = Some(5);
# fn foo(x: i32) { }
if let Some(x) = option {
    foo(x);
}
```

#### while let

```rust
let mut v = vec![1, 3, 5, 7, 11];
loop {
    match v.pop() {
        Some(x) =>  println!("{}", x),
        None => break,
    }
}

// ä¼˜é›…
let mut v = vec![1, 3, 5, 7, 11];
while let Some(x) = v.pop() {
    println!("{}", x);
}
```

### 4.22 traitå¯¹è±¡

å½“æ¶‰åŠåˆ°å¤šæ€çš„ä»£ç æ—¶, æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæœºåˆ¶æ¥å†³å®šå“ªä¸ªå…·ä½“çš„ç‰ˆæœ¬åº”è¯¥å¾—åˆ°æ‰§è¡Œã€‚è¿™å«åšâ€œåˆ†å‘â€ï¼ˆdispatchï¼‰ã€‚å¤§ä½“ä¸Šæœ‰ä¸¤ç§å½¢å¼çš„åˆ†å‘ï¼šé™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘ã€‚è™½ç„¶ Rust å–œæ¬¢é™æ€åˆ†å‘ï¼Œä¸è¿‡å®ƒä¹Ÿæä¾›äº†ä¸€ä¸ªå«åšâ€œtrait å¯¹è±¡â€çš„æœºåˆ¶æ¥æ”¯æŒåŠ¨æ€åˆ†å‘ã€‚

```rust
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }
fn do_something<T: Foo>(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something(x);
    do_something(y);
}
```

#### é™æ€åˆ†å‘

ä¸Šé¢çš„ä»£ç , åœ¨ç¼–è¯‘æ—¶å°±ä¼šè¢«ä¼˜åŒ–ä¸º

```rust
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something_u8(x);
    do_something_string(y);
}
```

ä½†æ˜¯åŒæ—¶ä¹Ÿå¼•å…¥äº†æ–°çš„é—®é¢˜, `ä»£ç è†¨èƒ€ code bloat`

#### åŠ¨æ€åˆ†å‘

Rust é€šè¿‡ä¸€ä¸ªå«åšâ€œtrait å¯¹è±¡â€çš„åŠŸèƒ½æä¾›åŠ¨æ€åˆ†å‘ã€‚æ¯”å¦‚è¯´`&Fooã€Box<Foo>`è¿™äº›å°±æ˜¯traitå¯¹è±¡ã€‚å®ƒä»¬æ˜¯ä¸€äº›å€¼ï¼Œå€¼ä¸­å‚¨å­˜å®ç°äº†ç‰¹å®š trait çš„ä»»æ„ç±»å‹ã€‚å®ƒçš„å…·ä½“ç±»å‹åªèƒ½åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šã€‚

ä»ä¸€äº›å®ç°äº†ç‰¹å®štraitçš„ç±»å‹çš„æŒ‡é’ˆä¸­ï¼Œå¯ä»¥ä»é€šè¿‡è½¬å‹(casting)ï¼ˆä¾‹å¦‚ï¼Œ`&x as &Foo`ï¼‰æˆ–è€…å¼ºåˆ¶è½¬å‹(coercing it)ï¼ˆä¾‹å¦‚ï¼ŒæŠŠ&xå½“åšå‚æ•°ä¼ é€’ç»™ä¸€ä¸ªæ¥æ”¶&Fooç±»å‹çš„å‡½æ•°ï¼‰æ¥å–å¾—traitå¯¹è±¡ã€‚

```rust
// è½¬å‹casting
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }

fn do_something(x: &Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&x as &Foo);
}

// å¼ºåˆ¶ç±»å‹ by concercing
# trait Foo { fn method(&self) -> String; }
# impl Foo for u8 { fn method(&self) -> String { format!("u8: {}", *self) } }
# impl Foo for String { fn method(&self) -> String { format!("string: {}", *self) } }

fn do_something(x: &Foo) {
    x.method();
}

fn main() {
    let x = "Hello".to_string();
    do_something(&x);
}
```

è™½ç„¶æ²¡æœ‰å¯¼è‡´ä»£ç è†¨èƒ€, ä½†æ˜¯å› ä¸ºè°ƒç”¨äº†è™šå‡½æ•°, ä¼šå¸¦æ¥æ›´å¤§çš„è¿è¡Œæ—¶å¼€é”€, ä¹Ÿä¼šå¤§å¤§é˜»æ­¢ä»»ä½•å†…è”ä»¥åŠç›¸å…³ä¼˜åŒ–çš„è¿›è¡Œ

#### ä¸ºä»€ä¹ˆç”¨æŒ‡é’ˆ

rusté»˜è®¤ä¸é€‚ç”¨æŒ‡é’ˆæ¥å­˜æ”¾æ•°æ®, å› æ­¤ç±»å‹æœ‰ç€ä¸åŒçš„å¤§å°, åœ¨ç¼–è¯‘æ—¶çŸ¥é“å€¼çš„å¤§å°, ä»¥åŠäº†è§£æŠŠå€¼ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°, å€¼åœ¨æ ˆä¸Šç§»åŠ¨, å€¼åœ¨å †ä¸Šåˆ†é…æˆ–è€…é‡Šæ”¾å¹¶å­˜å‚¨ç­‰æƒ…å†µ

ç”¨æŒ‡é’ˆæ¥å‚¨å­˜å€¼æ„å‘³ç€å½“æˆ‘ä»¬ä½¿ç”¨ trait å¯¹è±¡æ—¶å€¼çš„å¤§å°ï¼ˆsizeï¼‰æ˜¯æ— å…³çš„ï¼Œåªä¸æŒ‡é’ˆçš„å¤§å°ï¼ˆsizeï¼‰æœ‰å…³ã€‚

#### è¡¨ç°

å¯ä»¥åœ¨ä¸€ä¸ª trait å¯¹è±¡ä¸Šé€šè¿‡ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°æŒ‡é’ˆçš„è®°å½•è°ƒç”¨çš„ç‰¹æ€§å‡½æ•°é€šå¸¸å«åšâ€œè™šå‡½æ•°è¡¨â€ï¼ˆç”±ç¼–è¯‘å™¨åˆ›å»ºå’Œç®¡ç†ï¼‰ã€‚

```rust
# mod foo {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
# }
```

ä¸€ä¸ªtraitå¯¹è±¡å°±åƒåŒ…å«ä¸€ä¸ª`æ•°æ®`æŒ‡é’ˆå’Œ`è™šå‡½æ•°è¡¨`æŒ‡é’ˆçš„&Foo

æ•°æ®æŒ‡é’ˆæŒ‡å‘ trait å¯¹è±¡ä¿å­˜çš„æ•°æ®ï¼ˆæŸä¸ªæœªçŸ¥çš„ç±»å‹Tï¼‰ï¼Œå’Œä¸€ä¸ªè™šè¡¨æŒ‡é’ˆæŒ‡å‘å¯¹åº”Tçš„Fooå®ç°çš„è™šå‡½æ•°è¡¨ã€‚

ä¸€ä¸ªè™šè¡¨æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆçš„ç»“æ„ä½“ï¼ŒæŒ‡å‘æ¯ä¸ªå‡½æ•°å®ç°çš„å…·ä½“æœºå™¨ç ã€‚ä¸€ä¸ªåƒtrait_object.method()çš„å‡½æ•°è°ƒç”¨ä¼šä»è™šè¡¨ä¸­å–å‡ºæ­£ç¡®çš„æŒ‡é’ˆç„¶åè¿›è¡Œä¸€ä¸ªåŠ¨æ€è°ƒç”¨ã€‚ä¾‹å¦‚ï¼š

```rust
struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -> String,
}

// u8:

fn call_method_on_u8(x: *const ()) -> String {
    // The compiler guarantees that this function is only called
    // with `x` pointing to a u8.
    let byte: &u8 = unsafe { &*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 1,
    align: 1,

    // Cast to a function pointer:
    method: call_method_on_u8 as fn(*const ()) -> String,
};


// String:

fn call_method_on_String(x: *const ()) -> String {
    // The compiler guarantees that this function is only called
    // with `x` pointing to a String.
    let string: &String = unsafe { &*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    // Values for a 64-bit computer, halve them for 32-bit ones
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -> String,
};
```

#### å¯¹è±¡å®‰å…¨

å¹¶ä¸æ˜¯æ‰€æœ‰ trait éƒ½å¯ä»¥è¢«ç”¨æ¥ä½œä¸ºä¸€ä¸ª trait å¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œvector å®ç°äº†Cloneï¼Œä¸è¿‡å¦‚æœæˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ª trait å¯¹è±¡ï¼š

```rust
let v = vec![1, 2, 3];
let o = &v as &Clone;

error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &v as &Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &v as &Clone;
```

é”™è¯¯è¡¨æ˜Cloneå¹¶ä¸æ˜¯â€œå¯¹è±¡å®‰å…¨çš„ï¼ˆobject-safeï¼‰â€ã€‚åªæœ‰å¯¹è±¡å®‰å…¨çš„ trait æ‰èƒ½æˆä¸º trait å¯¹è±¡ã€‚ä¸€ä¸ªå¯¹è±¡å®‰å…¨çš„ trait éœ€è¦å¦‚ä¸‹ä¸¤æ¡ä¸ºçœŸï¼š

- trait å¹¶ä¸è¦æ±‚Self: Sized
- æ‰€æœ‰çš„æ–¹æ³•æ˜¯å¯¹è±¡å®‰å…¨çš„

é‚£ä¹ˆä»€ä¹ˆè®©ä¸€ä¸ªæ–¹æ³•æ˜¯å¯¹è±¡å®‰å…¨çš„å‘¢ï¼Ÿæ¯ä¸€ä¸ªæ–¹æ³•å¿…é¡»è¦æ±‚Self: Sizedæˆ–è€…å¦‚ä¸‹æ‰€æœ‰ï¼š

- å¿…é¡»æ²¡æœ‰ä»»ä½•ç±»å‹å‚æ•°
- å¿…é¡»ä¸ä½¿ç”¨Self
å¥½çš„ã€‚å¦‚ä½ æ‰€è§ï¼Œå‡ ä¹æ‰€æœ‰çš„è§„åˆ™éƒ½è°ˆåˆ°äº†Selfã€‚ä¸€ä¸ªç›´è§‚çš„ç†è§£æ˜¯â€œé™¤äº†ç‰¹æ®Šæƒ…å†µï¼Œ**`å¦‚æœä½ çš„ trait çš„æ–¹æ³•ä½¿ç”¨äº†Selfï¼Œå®ƒå°±ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„â€ã€‚`**

### 4.23 é—­åŒ…


```rust
let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
```

å‘½åå‡½æ•°æŒ‡å®šå…¨éƒ¨ç±»å‹æœ‰åŠ©äºåƒæ–‡æ¡£å’Œç±»å‹æ¨æ–­, è€Œé—­åŒ…çš„ç±»å‹åˆ™å¾ˆå°‘æœ‰æ–‡æ¡£å› ä¸ºä»–ä»¬æ˜¯åŒ¿åçš„

```rust
fn  plus_one_v1   (x: i32) -> i32 { x + 1 }
let plus_one_v2 = |x: i32| -> i32 { x + 1 };
let plus_one_v3 = |x: i32|          x + 1  ;
```

#### é—­åŒ…åŠç¯å¢ƒ

```rust
let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &mut num;

// è¿™æ ·ä¼šæœ‰ä¸€ä¸ªerror, å› ä¸ºé—­åŒ…å€Ÿç”¨äº†ç»‘å®š
```

#### moveé—­åŒ…

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨moveå…³é”®å­—å¼ºåˆ¶ä½¿æˆ‘ä»¬çš„é—­åŒ…å–å¾—å®ƒç¯å¢ƒçš„æ‰€æœ‰æƒ

```rust
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num); // è¿™é‡Œä¼šå–å¾—10

let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num); // è¿™é‡Œä¼šå–å¾—5
```

ä¸å…¶è·å–ä¸€ä¸ªæˆ‘ä»¬numçš„å¯å˜å¼•ç”¨, æˆ‘ä»¬å–å¾—äº†ä¸€ä¸ªæ‹·è´çš„æ‰€æœ‰æƒ

å¦ä¸€ä¸ªç†è§£moveé—­åŒ…çš„æ–¹æ³•ï¼šå®ƒç»™å‡ºäº†ä¸€ä¸ªæ‹¥æœ‰è‡ªå·±æ ˆå¸§çš„é—­åŒ…ã€‚æ²¡æœ‰moveï¼Œä¸€ä¸ªé—­åŒ…å¯èƒ½ä¼šç»‘å®šåœ¨åˆ›å»ºå®ƒçš„æ ˆå¸§ä¸Šï¼Œè€Œmoveé—­åŒ…åˆ™æ˜¯ç‹¬ç«‹çš„ã€‚ä¾‹å¦‚ï¼Œè¿™æ„å‘³ç€å¤§ä½“ä¸Šä½ ä¸èƒ½ä»å‡½æ•°è¿”å›ä¸€ä¸ªémoveé—­åŒ…ã€‚

#### é—­åŒ…å®ç°

rustçš„é—­åŒ…å®ç°å®é™…ä¸Šæ˜¯traitçš„è¯­æ³•ç³–, é€šè¿‡ä¸‰ä¸ªtraitæ¥åˆ†åˆ«é‡è½½:

- Fn
- FnMut
- FnOnce

Fnè·å–&selfï¼ŒFnMutè·å–&mut selfï¼Œè€ŒFnOnceè·å–selfã€‚è¿™åŒ…å«äº†æ‰€æœ‰3ç§é€šè¿‡é€šå¸¸å‡½æ•°è°ƒç”¨è¯­æ³•çš„selfã€‚ä¸è¿‡æˆ‘ä»¬å°†å®ƒä»¬åˆ†åœ¨ 3 ä¸ª trait é‡Œï¼Œè€Œä¸æ˜¯å•ç‹¬çš„ 1 ä¸ªã€‚è¿™ç»™äº†æˆ‘ä»¬å¤§é‡çš„å¯¹äºæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ªç§é—­åŒ…çš„æ§åˆ¶ã€‚

é—­åŒ…çš„`|| {}`è¯­æ³•æ˜¯ä¸Šé¢ 3 ä¸ª trait çš„è¯­æ³•ç³–ã€‚Rust å°†ä¼šä¸ºäº†ç¯å¢ƒåˆ›å»ºä¸€ä¸ªç»“æ„ä½“ï¼Œimplåˆé€‚çš„ traitï¼Œå¹¶ä½¿ç”¨å®ƒã€‚

#### é—­åŒ…ä½œä¸ºå‚æ•°

å› ä¸ºé—­åŒ…å®é™…ä¹Ÿæ˜¯trait

```rust
fn call_with_one<F>(some_closure: F) -> i32
    where F: Fn(i32) -> i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
```

å› ä¸ºæˆ‘ä»¬ç”¨ä¸€ä¸ªtraité™åˆ¶æ³›å‹, å®ƒå›äº‹å•æ€çš„, å¹¶ä¸”å› æ­¤æˆ‘ä»¬åœ¨é—­åŒ…ä¸­ä½¿ç”¨é™æ€åˆ†å‘, åœ¨rustä¸­, æˆ‘ä»¬å¯ä»¥åœ¨æ ˆä¸Šåˆ†é…æˆ‘ä»¬é—­åŒ…çš„ç¯å¢ƒ, å¹¶é™æ€åˆ†å‘è°ƒç”¨, å¦‚æœæˆ‘ä»¬æƒ³è¦åŠ¨æ€åˆ†å‘, traitå¯¹è±¡å¤„ç†è¿™æ ·çš„æƒ…å†µ

```rust
fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {
    some_closure(1)
}

let answer = call_with_one(&|x| x + 2);

assert_eq!(3, answer);
```

é€šå¸¸ä½ å¯ä»¥æŒ‡å®šé—­åŒ…çš„å‚æ•°ç”Ÿå‘½å‘¨æœŸ, æˆ‘ä»¬å¯ä»¥å†å‡½æ•°å£°æ˜ä¸ŠæŒ‡å®šå®ƒ

```rust
fn call_with_ref<'a, F>(some_closure:F) -> i32
    where F: Fn(&'a i32) -> i32 {
```

ç„¶è€Œè¿™å¯¼è‡´äº†ä¸€ä¸ªé—®é¢˜ã€‚å½“ä¸€ä¸ªå‡½æ•°æ‹¥æœ‰ä¸€ä¸ªæ˜¾å¼ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¸ªç”Ÿå‘½å‘¨æœŸå¿…é¡»è·Ÿæ•´ä¸ªè°ƒç”¨è¿™ä¸ªå‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸä¸€æ ·é•¿ã€‚å€Ÿç”¨æ£€æŸ¥å™¨ä¼šæŠ±æ€¨è¯´valueçš„ç”Ÿå‘½å‘¨æœŸå¹¶ä¸å¤Ÿé•¿ï¼Œå› ä¸ºå®ƒåªä½äºå£°æ˜ååœ¨å‡½æ•°ä½“çš„ä½œç”¨åŸŸå†…ã€‚

æˆ‘ä»¬éœ€è¦çš„æ˜¯åªä¸ºå®ƒçš„å‚æ•°å€Ÿç”¨å…¶è‡ªå·±çš„ä½œç”¨åŸŸçš„é—­åŒ…ï¼Œè€Œä¸æ˜¯æ•´ä¸ªå¤–å±‚å‡½æ•°çš„ä½œç”¨åŸŸã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´é«˜çº§çš„ Trait Boundï¼Œä½¿ç”¨for<...>è¯­æ³•ï¼š

```rust
fn call_with_ref<F>(some_closure:F) -> i32
    where F: for<'a> Fn(&'a i32) -> i32 {

    let value = 0;
    some_closure(&value)
}
```

#### å‡½æ•°æŒ‡é’ˆå’Œé—­åŒ…

ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆæœ‰ç‚¹åƒä¸€ä¸ªæ²¡æœ‰ç¯å¢ƒçš„é—­åŒ…

```rust
fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {
    some_closure(1)
}

fn add_one(i: i32) -> i32 {
    i + 1
}

let f = add_one;

let answer = call_with_one(&f);

assert_eq!(2, answer);
```

#### è¿”å›é—­åŒ…

æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥çš„å®ç°ä¸€ä¸ªå‡½æ•°å¯ä»¥è¿”å›ä¸€ä¸ªé—­åŒ…

```rust
fn factory() -> (Fn(i32) -> i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

ä¸ºäº†ä»å‡½æ•°è¿”å›ä¸€äº›ä¸œè¥¿, rustéœ€è¦çŸ¥é“è¿”å›ç±»å‹çš„å¤§å°, ä½†æ˜¯Fnæ˜¯ä¸€ä¸ªtrait, å¹¶ä¸èƒ½ç¡®å®šå¤§å°, æ‰€ä»¥æ­¤å¤„æˆ‘ä»¬ç®€å•çš„è§£å†³æ–¹æ¡ˆä¸ºæ›¿æ¢ä¸ºå¼•ç”¨, è¿™æ ·å°±å¯ä»¥ç¡®å®šå¤§å°äº†

```rust
fn factory() -> &(Fn(i32) -> i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

ä½†æ˜¯æ¥ä¸‹æ¥æˆ‘ä»¬ä¼šå‘ç°, æˆ‘ä»¬ç¼ºå¤±ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸ, ä½†æ˜¯factoryæ˜¯æ— å‚æ•°çš„, æ‰€ä»¥åªèƒ½ä½¿ç”¨`static

```rust
fn factory() -> &'static (Fn(i32) -> i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

æ¥ç€æˆ‘ä»¬é‡åˆ°å¦å¤–ä¸€ä¸ªé”™è¯¯, æˆ‘ä»¬å¹¶æ²¡æœ‰è¿”å›ä¸€ä¸ª&'static Fn(i32) -> i32ï¼Œè€Œæ˜¯è¿”å›äº†ä¸€ä¸ª[closure <anon>:7:9: 7:20]

å› ä¸ºæ¯ä¸ªé—­åŒ…ç”Ÿæˆäº†è‡ªå·±çš„ç¯å¢ƒstructå¹¶å®ç°äº†Fnå’Œå…¶ä»–ä¸€äº›ä¸œè¥¿, è¿™äº›ç±»å‹éƒ½æ˜¯åŒ¿åçš„, æ‰€ä»¥rustæŠŠå®ƒä»¬æ˜¾ç¤ºä¸º[closure<anon>], è€Œä¸æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„åå­—, è¿™é‡Œæˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹å‡ºæœŸæœ›æ˜¯è¿”å›ä¸€ä¸ªå¼•ç”¨, æˆ‘ä»¬ä¹Ÿå¹¶ä¸èƒ½ç›´æ¥ç»™å¯¹è±¡'staticç”Ÿå‘½å‘¨æœŸ, æ‰€ä»¥æˆ‘ä»¬æ¢å¦ä¸€ç§æ–¹æ³•, ä½¿ç”¨`Box`è£…ç®±Fnæ¥è¿”å›ä¸€ä¸ªtraitå¯¹è±¡

```rust
fn factory() -> Box<Fn(i32) -> i32> {
    let num = 5;

    Box::new(|x| x + num)
}


let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

ä½†æ˜¯è¿™é‡Œè¿˜æœ‰æœ€åä¸€ä¸ªé—®é¢˜, å› ä¸ºé—­åŒ…å€Ÿç”¨äº†å¼•ç”¨, ä½†æ˜¯numåœ¨å‡½æ•°è°ƒç”¨ç»“æŸä»¥å, æ ˆå¸§ä¹Ÿå°†æ¶ˆå¤±, æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨moveæ¥æ‹·è´ä¸€ä»½å¼•ç”¨

```rust
fn factory() -> Box<Fn(i32) -> i32> {
    let num = 5;

    Box::new(move |x| x + num)
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

### 4.24 é€šç”¨å‡½æ•°è°ƒç”¨è¯­æ³•

```rust
trait Foo {
    fn f(&self);
}

trait Bar {
    fn f(&self);
}

struct Baz;

impl Foo for Baz {
    fn f(&self) { println!("Bazâ€™s impl of Foo"); }
}

impl Bar for Baz {
    fn f(&self) { println!("Bazâ€™s impl of Bar"); }
}

let b = Baz;
```

å½“æˆ‘ä»¬åœ¨è°ƒç”¨`b.f()`æ—¶, rustä¸èƒ½çŸ¥é“ä½ è°ƒç”¨çš„æ˜¯å“ªä¸ªå‡½æ•°

```rust
# trait Foo {
#     fn f(&self);
# }
# trait Bar {
#     fn f(&self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&self) { println!("Bazâ€™s impl of Foo"); }
# }
# impl Bar for Baz {
#     fn f(&self) { println!("Bazâ€™s impl of Bar"); }
# }
# let b = Baz;

// è¿™é‡Œéœ€è¦æ˜¾å¼ä¼ é€’ä¸€ä¸ª&b
Foo::f(&b);
Bar::f(&b);
```

#### å°–æ‹¬å·å½¢å¼ angle-bracket form


```rust
Trait::method(args);
```

ä¸Šé¢çš„è°ƒç”¨å½¢å¼, å…¶å®æ˜¯ä¸‹é¢å½¢å¼çš„ç¼©å†™

```rust
<Type as Trait>::method(args);
```

### 4.25 crateå’Œæ¨¡å—

#### å®šä¹‰æ¨¡å—

```rust
mod english {
    mod greetings {
    }

    mod farewells {
    }
}

mod japanese {
    mod greetings {
    }

    mod farewells {
    }
}
```

#### å¯¼å…¥å¤–éƒ¨çš„åŒ…è£…ç®±

```rust
extern crate phrases;

fn main() {
    println!("Hello in English: {}", phrases::english::greetings::hello());
    println!("Goodbye in English: {}", phrases::english::farewells::goodbye());

    println!("Hello in Japanese: {}", phrases::japanese::greetings::hello());
    println!("Goodbye in Japanese: {}", phrases::japanese::farewells::goodbye());
}
```

`extern crate`å£°æ˜å‘Šè¯‰Rustæˆ‘ä»¬éœ€è¦ç¼–è¯‘å’Œé“¾æ¥`phrases`åŒ…è£…ç®±, ç„¶åæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨`phrases`çš„æ¨¡å—äº†, éœ€è¦æ³¨æ„çš„æ˜¯Rusté»˜è®¤éƒ½æ˜¯ç§æœ‰çš„, éœ€è¦å¯¼å…¥å¤–éƒ¨åŒ…è£…ç®±çš„è¯, éœ€è¦ç¡®ä¿é‡Œé¢ä½¿ç”¨çš„æ¨¡å—æ˜¯`pub`çš„

#### ç”¨useå¯¼å…¥æ¨¡å—

```rust
use phrases::english::{greetings, farewells};
```

#### ä½¿ç”¨`pub use`é‡å¯¼å‡º

ä½ ä¸ä»…å¯ä»¥ç”¨useæ¥ç®€åŒ–æ ‡è¯†ç¬¦ã€‚ä½ ä¹Ÿå¯ä»¥åœ¨åŒ…è£…ç®±å†…ç”¨å®ƒé‡å¯¼å‡ºå‡½æ•°åˆ°å¦ä¸€ä¸ªæ¨¡å—ä¸­ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥å±•ç¤ºä¸€ä¸ªå¤–éƒ¨æ¥å£å¯èƒ½å¹¶ä¸ç›´æ¥æ˜ å°„åˆ°å†…éƒ¨ä»£ç ç»“æ„ã€‚

```rust
pub use self::greetings::hello;
pub use self::farewells::goodbye;

mod greetings;
mod farewells;
```

#### å¤æ‚çš„å¯¼å…¥

```rust
extern crate phrases as sayings;

use sayings::japanese::greetings as ja_greetings;
use sayings::japanese::farewells::*;
use sayings::english::{self, greetings as en_greetings, farewells as en_farewells};

fn main() {
    println!("Hello in English; {}", en_greetings::hello());
    println!("And in Japanese: {}", ja_greetings::hello());
    println!("Goodbye in English: {}", english::farewells::goodbye());
    println!("Again: {}", en_farewells::goodbye());
    println!("And in Japanese: {}", goodbye());
}
```

### 4.26 constå’Œstatic

```rust
const N: i32 = 5;
```

å¸¸é‡è´¯ç©¿äºæ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸ. æ›´å…·ä½“çš„ï¼ŒRust ä¸­çš„å¸¸é‡å¹¶æ²¡æœ‰å›ºå®šçš„å†…å­˜åœ°å€ã€‚è¿™æ˜¯å› ä¸ºå®é™…ä¸Šå®ƒä»¬ä¼šè¢«å†…è”åˆ°ç”¨åˆ°å®ƒä»¬çš„åœ°æ–¹ã€‚ä¸ºæ­¤å¯¹åŒä¸€å¸¸é‡çš„å¼•ç”¨å¹¶ä¸èƒ½ä¿è¯å¼•ç”¨åˆ°ç›¸åŒçš„å†…å­˜åœ°å€ã€‚

#### static

Rust ä»¥é™æ€é‡çš„æ–¹å¼æä¾›äº†ç±»ä¼¼â€œå…¨å±€å˜é‡â€çš„åŠŸèƒ½ã€‚å®ƒä»¬ä¸å¸¸é‡ç±»ä¼¼ï¼Œä¸è¿‡é™æ€é‡åœ¨ä½¿ç”¨æ—¶å¹¶ä¸å†…è”ã€‚è¿™æ„å‘³ç€å¯¹æ¯ä¸€ä¸ªå€¼åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä¸”ä½äºå†…å­˜ä¸­çš„å›ºå®šä½ç½®ã€‚

```rust
static N: i32 = 5;
```

#### å¯å˜æ€§

å› ä¸ºè¿™æ˜¯å¯å˜çš„ï¼Œä¸€ä¸ªçº¿ç¨‹å¯èƒ½åœ¨æ›´æ–°NåŒæ—¶å¦ä¸€ä¸ªåœ¨è¯»å–å®ƒï¼Œå¯¼è‡´å†…å­˜ä¸å®‰å…¨ã€‚å› æ­¤è®¿é—®å’Œæ”¹å˜ä¸€ä¸ªstatic mutæ˜¯[ä¸å®‰å…¨ï¼ˆunsafeï¼‰](unsafe ä¸å®‰å…¨ä»£ç .md)çš„ï¼Œå› æ­¤å¿…é¡»åœ¨unsafeå—ä¸­æ“ä½œï¼š

```rust
# static mut N: i32 = 5;

unsafe {
    N += 1;

    println!("N: {}", N);
}
```

#### åˆå§‹åŒ–

constå’Œstaticéƒ½è¦æ±‚èµ‹äºˆä¸€ä¸ªå€¼, å¿…é¡»åªèƒ½è¢«èµ‹äºˆä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼çš„å€¼, ä½ ä¸èƒ½ç”¨ä¸€ä¸ªå‡½æ•°è°ƒç”¨çš„è¿”å›å€¼æˆ–ä»»ä½•ç›¸ä¼¼çš„å¤åˆå€¼æˆ–åœ¨è¿è¡Œæ—¶èµ‹å€¼ã€‚

#### åº”è¯¥å¦‚ä½•é€‰æ‹©

å‡ ä¹æ‰€æœ‰æ—¶å€™ï¼Œå¦‚æœä½ å¯ä»¥åœ¨ä¸¤è€…ä¹‹é—´é€‰æ‹©ï¼Œé€‰æ‹©constã€‚å®é™…ä¸Šä½ å¾ˆå°‘éœ€è¦ä½ çš„å¸¸é‡å…³è”ä¸€ä¸ªå†…å­˜ä½ç½®ï¼Œè€Œä¸”ä½¿ç”¨constå…è®¸ä½ ä¸æ­¢åœ¨åœ¨è‡ªå·±çš„åŒ…è£…ç®±è¿˜å¯ä»¥åœ¨ä¸‹æ¸¸åŒ…è£…ç®±ä¸­ä½¿ç”¨åƒå¸¸æ•°æ‰©æ•£è¿™æ ·çš„ä¼˜åŒ–ã€‚


```rust

```

```rust

```