### 4.2 函数

#### 表达式 VS 语句

Rust主要是一个基于表达式的语言, 只有两种语句, 其他一切都是表达式

```rust
fn add_one(x: i32) -> i32 {
  x + 1
}

// 此处如果加上semicolon, 则不会正常返回, 会被认为是一个语句, 而表达式则会返回一个值, 这才是推荐的写法
```

#### diverging function 发散函数

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
// 类型throw一个error
```

#### 函数指针

```rust
fn plus_one(i: i32) -> i32 {
  i + 1
}

let f: fn(i32) -> i32 = plus_one

let result = f(5)
```

### 4.3 primitive types 原生类型

1. 布尔型
2. char
3. 数字类型 `i8`, `i16`, `u16`, `f64`, `isize`
4. 数组

```rust
let a = [0; 20] // a: [i32; 20], 初始化了含有20个0的数组
```

> 切片 slices

```rust
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // A slice containing all of the elements in `a`.
let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.
```

5. str 最原始的字符串类型, 为不定长类型
6. 元组 tuples

> 元组的索引

```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

7. 函数

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i: 32) -> i32 = foo;
```

### If语句

因为if是一个表达式, 所以可以这么写

```rust
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
```

### loop循环

提供了三种方法来进行一些迭代才做, 分别为`loop`, `while`以及`for`

1. loop

这个为无限循环, 使用`break`来终止循环

2. while

```rust
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!("{}", x);

    if x % 5 == 0 {
        done = true;
    }
}
```

3. for

```rust
for x in 0..10 {
    println!("{}", x); // x: i32
}

// 更抽象的形式 这个表达式是一个迭代器
for var in expression {
    code
}
```

4. Enumerate方法

当你想知道已经循环了多少次的时候, 需要使用`.enumerate()函数`

```rust
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}
```

5. 循环标签 Loop labels

```rust
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}
```

### 4.7 Vectors

实现的标准库为Vec<T>, 也可以使用vec!宏来创建它

```rust
let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>
let v = vec![0; 10]; // ten zeroes
```

#### 访问元素

值得注意的是, 必须使用`usize`类型的值进行索引

```rust
let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// Works:
v[i];

// Doesn’t:
v[j];
```

为了不出现out of bounds error, 我们可以使用`get`或者`get_mut`来获取元素, 若索引无效的话, 会返回None

```rust
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}
```

#### iterate

```rust
let mut v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("A reference to {}", i);
}

for i in &mut v {
    println!("A mutable reference to {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}

// 需要注意的是 最后一个方法将不能再次使用同样的方法遍历vector, 其余两种使用引用的方法就不会出现这样的问题
```

### 4.8 所有权

rust注重安全和速度, 通过很多zero-cost abstractions 零开销抽象来实现这些目标, 分析都在编译时完成, 不需要再运行时为这些功能付出任何开销

#### 所有权 ownership

Rust 中的[变量绑定](Variable Bindings)有一个属性：它们有它们所绑定的的值的所有权。这意味着当一个绑定离开作用域，它们绑定的资源就会被释放。例如：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

当进入作用域时, 一个vector在栈上被创建, 并在堆上为它的3个元素分配了空间, 离开作用域以后, rust将会清理掉与vector相关的一切, 甚至是堆上的分配的内存


#### 移动语义 move semantics

然而这里有更巧妙的地方：Rust 确保了对于任何给定的资源都正好（只）有一个绑定与之对应。例如，如果我们有一个 vector，我们可以把它赋予另外一个绑定：

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]); // error
```

下面的例子会出现一样的错误, 我们把所有权转移给了别的绑定时, 我们说我们移动了我们引用的值

```rust
fn take(v: Vec<i32>) {
    // What happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

#### Copy类型

我们已经知道了当所有权被转移给另一个绑定以后，你不能再使用原始绑定。然而，有一个trait会改变这个行为，它叫做Copy。我们还没有讨论到 trait，不过目前，你可以理解为一个为特定类型增加额外行为的标记。例如：

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);

// i32并没有指向其他数据的指针, 对他的拷贝是一个完整的拷贝
```

所有基本类型都实现了`copy trait`, 不遵循所有权规则
