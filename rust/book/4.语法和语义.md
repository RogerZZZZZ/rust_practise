### 4.2 函数

#### 表达式 VS 语句

Rust主要是一个基于表达式的语言, 只有两种语句, 其他一切都是表达式

```rust
fn add_one(x: i32) -> i32 {
  x + 1
}

// 此处如果加上semicolon, 则不会正常返回, 会被认为是一个语句, 而表达式则会返回一个值, 这才是推荐的写法
```

#### diverging function 发散函数

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
// 类型throw一个error
```

#### 函数指针

```rust
fn plus_one(i: i32) -> i32 {
  i + 1
}

let f: fn(i32) -> i32 = plus_one

let result = f(5)
```

### 4.3 primitive types 原生类型

1. 布尔型
2. char
3. 数字类型 `i8`, `i16`, `u16`, `f64`, `isize`
4. 数组

```rust
let a = [0; 20] // a: [i32; 20], 初始化了含有20个0的数组
```

> 切片 slices

```rust
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // A slice containing all of the elements in `a`.
let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.
```

5. str 最原始的字符串类型, 为不定长类型
6. 元组 tuples

> 元组的索引

```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

7. 函数

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i: 32) -> i32 = foo;
```

### If语句

因为if是一个表达式, 所以可以这么写

```rust
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
```

### loop循环

提供了三种方法来进行一些迭代才做, 分别为`loop`, `while`以及`for`

1. loop

这个为无限循环, 使用`break`来终止循环

2. while

```rust
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!("{}", x);

    if x % 5 == 0 {
        done = true;
    }
}
```

3. for

```rust
for x in 0..10 {
    println!("{}", x); // x: i32
}

// 更抽象的形式 这个表达式是一个迭代器
for var in expression {
    code
}
```

4. Enumerate方法

当你想知道已经循环了多少次的时候, 需要使用`.enumerate()函数`

```rust
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}
```

5. 循环标签 Loop labels

```rust
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}
```

### 4.7 Vectors

实现的标准库为Vec<T>, 也可以使用vec!宏来创建它

```rust
let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>
let v = vec![0; 10]; // ten zeroes
```

#### 访问元素

值得注意的是, 必须使用`usize`类型的值进行索引

```rust
let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// Works:
v[i];

// Doesn’t:
v[j];
```

为了不出现out of bounds error, 我们可以使用`get`或者`get_mut`来获取元素, 若索引无效的话, 会返回None

```rust
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}
```

#### iterate

```rust
let mut v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("A reference to {}", i);
}

for i in &mut v {
    println!("A mutable reference to {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}

// 需要注意的是 最后一个方法将不能再次使用同样的方法遍历vector, 其余两种使用引用的方法就不会出现这样的问题
```

### 4.8 所有权

rust注重安全和速度, 通过很多zero-cost abstractions 零开销抽象来实现这些目标, 分析都在编译时完成, 不需要再运行时为这些功能付出任何开销

#### 所有权 ownership

Rust 中的[变量绑定](Variable Bindings)有一个属性：它们有它们所绑定的的值的所有权。这意味着当一个绑定离开作用域，它们绑定的资源就会被释放。例如：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

当进入作用域时, 一个vector在栈上被创建, 并在堆上为它的3个元素分配了空间, 离开作用域以后, rust将会清理掉与vector相关的一切, 甚至是堆上的分配的内存


#### 移动语义 move semantics

然而这里有更巧妙的地方：Rust 确保了对于任何给定的资源都正好（只）有一个绑定与之对应。例如，如果我们有一个 vector，我们可以把它赋予另外一个绑定：

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]); // error
```

下面的例子会出现一样的错误, 我们把所有权转移给了别的绑定时, 我们说我们移动了我们引用的值

```rust
fn take(v: Vec<i32>) {
    // What happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

#### Copy类型

我们已经知道了当所有权被转移给另一个绑定以后，你不能再使用原始绑定。然而，有一个trait会改变这个行为，它叫做Copy。我们还没有讨论到 trait，不过目前，你可以理解为一个为特定类型增加额外行为的标记。例如：

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);

// i32并没有指向其他数据的指针, 对他的拷贝是一个完整的拷贝
```

所有基本类型都实现了`copy trait`, 不遵循所有权规则


### 4.9 引用与借用

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

// can not use v1 v2 again
```

然后上面的并不是rust理想的代码

```rust
fn main() {
    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed.
    fn sum_vec(v: &Vec<i32>) -> i32 {
        return v.iter().fold(0, |a, &b| a + b);
    }
    // Borrow two vectors and sum them.
    // This kind of borrowing does not allow mutation through the borrowed reference.
    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
        // Do stuff with `v1` and `v2`.
        let s1 = sum_vec(v1);
        let s2 = sum_vec(v2);
        // Return the answer.
        s1 + s2
    }

    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5, 6];

    let answer = foo(&v1, &v2);
    println!("{}", answer);
}
```

引用是不可能变的, 意味着在foo当中, 向量完全不能被改变

```rust
fn foo(v: &Vec<i32>) {
     v.push(5); // cannot borrow immutable borrowed content `*v` as mutable
}

let v = vec![];

foo(&v);
```

#### &mut 引用

这是第二种类型的引用: &mut T, 一个可变引用允许你改变你借用的资源

```rust
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

#### 规则

1. 任何借用必须位于比拥有者更小的作用域
2. 对于同一个资源的借用, 以下的情况不能同时出现在同一个作用域下: 简单的说就是同一个作用域下不能同时存在不可变和可变的引用
- 1个或者多个不可变引用(&T)
- 唯一1个可变引用(&mut T)

```rust
fn main() {
    let mut x = 5;

    let y = &mut x;    // -+ &mut borrow of `x` starts here.
                       //  |
    *y += 1;           //  |
                       //  |
    println!("{}", x); // -+ - Try to borrow `x` here.
}                      // -+ &mut borrow of `x` ends here.
```

解决方法为上面的代码, 添加大括号即可

#### 释放后使用

引用必须与它引用的值存活的一样长

```rust
let y: &i32;
let x = 5;
y = &x;

println!("{}", y);

// error: x does not live long enough
```

在上面的例子中, y在x之前被申明, 所以y的生命周期更长, 这是不被允许的

### 4.10 生命周期

```rust

```

```rust

```